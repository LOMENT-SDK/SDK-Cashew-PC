package com.loment.cashewnut.sthithi.connection;

import javax.microedition.io.HttpConnection;

import org.bouncycastle.crypto.digests.MD5Digest;

public class DigestAuthHandler {

	private String username;
	private String password;
	private String httpMethod;
	private String uri;
	private String realm;
	/* private */ String nonce;
	private String count;
	private String cnonce;
	private String qop;
	private String opaque;
	private String algor;
	private boolean stale;
	private int ncount;

	public DigestAuthHandler(String u, String p) {
		username = u;
		password = p;
	}

	public void prepareHeaders(HttpConnection c, String uri) throws Exception {
		this.uri = uri;
		String h = "Digest ";

		if (username != null)
			h = h + "username=\"" + username + "\", ";
		if (realm != null)
			h = h + "realm=\"" + realm + "\", ";
		if (nonce != null)
			h = h + "nonce=\"" + nonce + "\", ";
		if (uri != null)
			h = h + "uri=\"" + uri + "\", ";
		if (opaque != null)
			h = h + "opaque=\"" + opaque + "\", ";

		if (qop != null) {
			h = h + "qop=\"" + qop + "\", ";
			// cnonce and nonce-count are required if qop is present.
			//
			// cnonce is a random number generated by the client.
			// You should use your device build-in random number
			// generator to produce it.
			cnonce = "0a4f113b";
			h = h + "cnonce=\"" + cnonce + "\", ";
			h = h + "nc=" + count + ", ";

			// Increase counter by one.
			// The counter will be reset when a new nonce comes in.

			String nc = Integer.toHexString(ncount);
			count = new String("00000000").substring(nc.length()) + nc;
			ncount++;
		}

		// For some reason, apache sends back algorithm "D".
		// MD5 is assumed here.
		// if(algor != null)
		// h = h + "algorithm=\"" + algor + "\", ";
		// else
		h = h + "algorithm=\"MD5\", ";

		h = h + "response=\"" + getDigest() + "\"";
		// System.err.println("Header =" + h);
		c.setRequestProperty("Authorization", h);
	}

	public boolean processHeaders(HttpConnection c) throws Exception {
		if (c.getResponseCode() == 401) {
			httpMethod = c.getRequestMethod();
			// uri = c.getFile();

			parse(c.getHeaderField("WWW-Authenticate"));

			// need to re-send request
			return true;
		} else {
			return false;
		}
	}

	private void parse(String header) {
		int i, j;
		String propvalue, prop, value;
		// System.err.println(""+header);
		// Get rid of string "Digest"
		i = header.indexOf(" ");
		header = header.substring(i + 1).trim();

		while (header.length() > 0) {
			i = header.indexOf(",");
			propvalue = header;
			if (i != -1) {
				propvalue = header.substring(0, i).trim();
				header = header.substring(i + 1).trim();
			} else {
				header = "";
			}
			j = propvalue.indexOf("=");
			prop = propvalue.substring(0, j).toLowerCase();
			value = propvalue.substring(j + 1).trim();
			// Get rid of quote marks
			if (value.startsWith("\"")) {
				value = value.substring(1, value.length() - 1);
			}
			value = value.trim();
			if (prop.compareTo("qop") == 0)
				qop = value;
			else if (prop.compareTo("nonce") == 0)
				setNonce(value);
			else if (prop.compareTo("realm") == 0)
				realm = value;
			else if (prop.compareTo("opaque") == 0)
				opaque = value;
			else if (prop.compareTo("algorithm") == 0)
				algor = value;
			// else if(prop.compareTo("domain") == 0)
			// uri = value;

		}
	}

	private void setNonce(String n) {

		// If this is a new nonce, reset counter
		String c;
		if (nonce == null)
			ncount = 1;
		else if (n.compareTo(nonce) != 0)
			ncount = 1;
		// else ncount++;
		c = Integer.toHexString(ncount);
		count = new String("00000000").substring(c.length()) + c;

		nonce = n;
	}

	private String getDigest() {
		String plaintext;
		String A1, A2;

		if (username == null || password == null || realm == null || uri == null || nonce == null)
			return "";

		if (username.length() == 0 || password.length() == 0 || realm.length() == 0 || uri.length() == 0
				|| nonce.length() == 0)
			return "";

		A1 = getA1();
		A2 = getA2();

		if (qop == null)
			plaintext = A1 + ":" + nonce + ":" + A2;
		else
			plaintext = A1.trim() + ":" + nonce.trim() + ":" + count.trim() + ":" + cnonce.trim() + ":" + qop.trim()
					+ ":" + A2.trim();
		// System.err.println("A1:" + A1 + " A2:" + A2 + " plaintext:" +
		// plaintext);
		MD5Digest md5 = new MD5Digest();
		byte[] plainbytes = plaintext.getBytes();
		md5.update(plainbytes, 0, plainbytes.length);
		byte[] digestbytes = new byte[md5.getDigestSize()];
		md5.doFinal(digestbytes, 0);

		return convert2Hex(digestbytes, 16);
	}

	private String getA1() {
		String plaintext, digest;

		plaintext = username + ":" + realm + ":" + password;

		MD5Digest md5 = new MD5Digest();
		byte[] plainbytes = plaintext.getBytes();
		md5.update(plainbytes, 0, plainbytes.length);
		byte[] digestbytes = new byte[md5.getDigestSize()];
		md5.doFinal(digestbytes, 0);

		digest = convert2Hex(digestbytes, 16);

		/*
		 * No MD5-sess support right now
		 * if(algor.toLowerCase().compareTo("md5-sess") != 0) return digest;
		 * 
		 * digest += ":" + nonce + ":" + cnonce;
		 * 
		 * MD.update(digest.getBytes());
		 * 
		 * digest = convert2Hex(MD.digest(), 16);
		 */

		return digest;
	}

	private String getA2() {
		String plaintext;

		plaintext = httpMethod + ":" + uri;

		MD5Digest md5 = new MD5Digest();
		byte[] plainbytes = plaintext.getBytes();
		md5.update(plainbytes, 0, plainbytes.length);
		byte[] digestbytes = new byte[md5.getDigestSize()];
		md5.doFinal(digestbytes, 0);

		return convert2Hex(digestbytes, 16);
	}

	private String convert2Hex(byte[] buf, int length) {

		String T = "";

		for (int x = 0; x < length; x++) {
			int y = buf[x];
			if (y < 0)
				y += 256;
			String d = Integer.toHexString(y);
			if (d.length() == 1)
				T += "0";
			T += d;
		}
		return T;
	}
}
